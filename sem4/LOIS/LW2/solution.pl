% Лабораторная работа №2 по дисциплине "Логические основы интеллектуальных систем"
% Выполнена студентом группы 221703 БГУИР:
% - Самута Даниил Владимирович
% Вариант: 1, последнее изменение: 30.05.2024

% Данный файл является исходным кодом к программе, решающий следующую задачу:

% Два береги реки. На одном берегу есть 3 миссионера и 3 людоеда, требуется с помощью лодки
% вмещающей не более 2 человек, переправить всех на другой берег. Число присутствующих миссионеров
% на берегу и в лодке должно быть всегда не меньше числа людоедов.

check(CL, ML, CR, MR) :-
    ML >= 0, CL >= 0, MR >= 0, CR >= 0, % Количество людей не может быть отрицательным
    (ML >= CL; ML = 0), % На левом берегу должно быть больше миссионеров, чем людоедов, либо не должно быть миссионеров вовсе
    (MR >= CR; MR = 0). % На правом берегу должно быть больше миссионеров, чем людоедов, либо не должно быть миссионеров вовсе

% Возможные перемещения:
move([CL,ML,CR,MR,left],[CL,ML2,CR,MR2,right], 'Два миссионера переплывают реку слева направо') :-
	% Два миссионера переплывают реку слева направо
	MR2 is MR+2,
	ML2 is ML-2,
	check(CL,ML2,CR,MR2).	

move([CL,ML,CR,MR,left],[CL2,ML,CR2,MR,right], 'Два каннибала переплывают реку слева направо') :-
	% Два каннибала переплывают реку слева направо
	CR2 is CR+2,
	CL2 is CL-2,
	check(CL2,ML,CR2,MR).

move([CL,ML,CR,MR,right],[CL,ML2,CR,MR2,left], 'Два миссионера переплывают реку справа налево') :-
	% Два миссионера переплывают реку справа налево
	MR2 is MR-2,
	ML2 is ML+2,
	check(CL,ML2,CR,MR2).

move([CL,ML,CR,MR,right],[CL2,ML,CR2,MR,left], 'Два каннибала переплывают реку справа налево') :-
	% Два каннибала переплывают реку справа налево
	CR2 is CR-2,
	CL2 is CL+2,
	check(CL2,ML,CR2,MR).

move([CL,ML,CR,MR,left],[CL2,ML2,CR2,MR2,right], 'Один миссионер и один каннибал переплывают реку слева направо') :-
	%  Один миссионер и один каннибал переплывают реку слева направо
	CR2 is CR+1,
	CL2 is CL-1,
	MR2 is MR+1,
	ML2 is ML-1,
	check(CL2,ML2,CR2,MR2).

move([CL,ML,CR,MR,right],[CL2,ML2,CR2,MR2,left], 'Один миссионер и один каннибал переплывают реку справа налево') :-
	%  Один миссионер и один каннибал переплывают реку справа налево
	CR2 is CR-1,
	CL2 is CL+1,
	MR2 is MR-1,
	ML2 is ML+1,
	check(CL2,ML2,CR2,MR2).

move([CL,ML,CR,MR,left],[CL,ML2,CR,MR2,right], 'Один миссионер переплывает реку слева направо') :-
	% Один миссионер переплывает реку слева направо
	MR2 is MR+1,
	ML2 is ML-1,
	check(CL,ML2,CR,MR2).

move([CL,ML,CR,MR,left],[CL2,ML,CR2,MR,right], 'Один каннибал переплывает реку слева направо') :-
	% Один каннибал переплывает реку слева направо
	CR2 is CR+1,
	CL2 is CL-1,
	check(CL2,ML,CR2,MR).

move([CL,ML,CR,MR,right],[CL,ML2,CR,MR2,left], 'Один миссионер переплывает реку справа налево') :-
	% Один миссионер переплывает реку справа налево
	MR2 is MR-1,
	ML2 is ML+1,
	check(CL,ML2,CR,MR2).

move([CL,ML,CR,MR,right],[CL2,ML,CR2,MR,left], 'Один каннибал переплывает реку справа налево') :-
	% Один каннибал переплывает реку справа налево
	CR2 is CR-1,
	CL2 is CL+1,
	check(CL2,ML,CR2,MR).

solve(FinalState, FinalState, _, Path) :-
    reverse(Path, Solution), % Переворачиваем Path, результат записываем в Solution
    print_solution(Solution). % Вывод Solution в консоль.

solve(CurrentState, FinalState, Visited, Path) :-
    move(CurrentState, NextState, Action), % переход от одного состояния к следующему
    \+ member(NextState, Visited), % проверка, что такое состояние ещё не было достигнуто, предотвращает циклы в поиске решения.
    solve(NextState, FinalState, [NextState | Visited], [Action | Path]). % рекурсивно вызываем для перехода в следующее состояние, добавляем NextState в Visited и Action в Path.

% Вывод решения в консоль. 
print_solution([]). % Остановка вывода, когда T будет пустым списком.
print_solution([H | T]) :-
    write(H), nl, % записываем один шаг и вызываем 
    print_solution(T).

% Стартовое положение миссионеров и каннибалов, запуск поиска и вывода.
start(InitialState, FinalState) :-
    solve(InitialState, FinalState, [InitialState], []). % вызываем поиск решения для текущего начального состояния и конечного, сразу добавляя InitialState в Visited.					